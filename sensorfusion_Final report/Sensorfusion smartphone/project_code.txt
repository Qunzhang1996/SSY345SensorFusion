[xhat, meas] = filterTemplate();

%%Task2

%filter and away from disturbance

[mu_acc, Sigma_acc] = approxGaussianTransform(meas.acc(:, ~any(isnan(meas.acc), 1)))
[mu_gyr, Sigma_gyr] = approxGaussianTransform(meas.gyr(:, ~any(isnan(meas.gyr), 1)))
[mu_mag, Sigma_mag] = approxGaussianTransform(meas.mag(:, ~any(isnan(meas.mag), 1)))
t1=meas.acc(:, ~any(isnan(meas.acc),1));
t2=meas.gyr(:, ~any(isnan(meas.gyr),1));
t3=meas.mag(:, ~any(isnan(meas.mag),1));
plothistogram(t1,mu_acc,Sigma_acc,t1);
plothistogram(t2,mu_gyr,Sigma_gyr,t2);
plothistogram(t3,mu_mag,Sigma_mag,t3);


%%Task 3

m0=[0;35.9880;-6.2037];
norm(m0)

Task 4

m=[-8.90775941939827;
    -34.8681023729396;
    -6.20365672999933];
  m0=[0 sqrt(m(1)^2+m(2)^2) m(3)]'

%%task 11

[xhat1, meas1] = filterTemplate_new();
% yaw roll pith

euler_est = q2euler(xhat1.x);
euler_ore = q2euler(meas1.orient);
figure('Position',[300 300 600 400]);hold on;
for i=1:3
    subplot(3,1,i);hold on
    plot(euler_est(i,:),'color','red','LineWidth',1);
    plot(euler_ore(i,:),'color','black','LineWidth',1);
    ylim([-4 4])
    legend('estimate','Orient')
end



function [xhat, meas] = filterTemplate_new(calAcc, calGyr, calMag)
% FILTERTEMPLATE  Filter template
%
% This is a template function for how to collect and filter data
% sent from a smartphone live.  Calibration data for the
% accelerometer, gyroscope and magnetometer assumed available as
% structs with fields m (mean) and R (variance).
%
% The function returns xhat as an array of structs comprising t
% (timestamp), x (state), and P (state covariance) for each
% timestamp, and meas an array of structs comprising t (timestamp),
% acc (accelerometer measurements), gyr (gyroscope measurements),
% mag (magnetometer measurements), and orint (orientation quaternions
% from the phone).  Measurements not availabe are marked with NaNs.
%
% As you implement your own orientation estimate, it will be
% visualized in a simple illustration.  If the orientation estimate
% is checked in the Sensor Fusion app, it will be displayed in a
% separate view.
%
% Note that it is not necessary to provide inputs (calAcc, calGyr, calMag).

  %% Setup necessary infrastructure
  import('com.liu.sensordata.*');  % Used to receive data.
  % mu_acc=[-0.0698351684120345;0.129599040310337;9.86074277407344];
  % mu_gyr=[-5.93631948089065e-05; -0.000134828649879018 ;5.45399353542027e-05];
  % mu_mag=[-8.90775941939827;-34.8681023729396;-6.20365672999933];

  %% Filter settings
  t0 = [];  % Initial time (initialize on first data received)
  nx = 4;   % Assuming that you use q as state variable.
  % Add your filter settings here.
  Sigma_gyr= diag([5.25831218863433e-07 2.00191667338357e-06 3.08362917989368e-07]);
  Sigma_acc=diag([5.37642075936609e-05 4.16257582862943e-05 0.000362015694832598]);
  Sigma_mag=diag([0.0812144578038627 0.122244652116890 0.0961734187830164]);
  g0=[-0.0698351684120345;0.129599040310337;9.86074277407344];
  m0=[0;35.9880;-6.2037];
  L=norm(m0);
  % Current filter state.
  x = [1; 0; 0 ;0];
  P = eye(nx, nx);

  % Saved filter states.
  xhat = struct('t', zeros(1, 0),...
                'x', zeros(nx, 0),...
                'P', zeros(nx, nx, 0));

  meas = struct('t', zeros(1, 0),...
                'acc', zeros(3, 0),...
                'gyr', zeros(3, 0),...
                'mag', zeros(3, 0),...
                'orient', zeros(4, 0));
  try
    %% Create data link
    server = StreamSensorDataReader(3400);
    % Makes sure to resources are returned.
    sentinel = onCleanup(@() server.stop());

    server.start(1);  % Start data reception.

    % Used for visualization.
    figure(1);
    subplot(1, 2, 1);
    ownView = OrientationView('Own filter', gca);  % Used for visualization.
    googleView = [];
    counter = 0;  % Used to throttle the displayed frame rate.

    %% Filter loop
    while server.status()  % Repeat while data is available
      % Get the next measurement set, assume all measurements
      % within the next 5 ms are concurrent (suitable for sampling
      % in 100Hz).
      data = server.getNext(5);

      if isnan(data(1))  % No new data received
        continue;        % Skips the rest of the look
      end
      t = data(1)/1000;  % Extract current time

      if isempty(t0)  % Initialize t0
        t0 = t;
      end

      gyr = data(1, 5:7)';
      if ~any(isnan(gyr))  % Gyro measurements are available.
        % Do something
        [x,P] =tu_qw(x, P, gyr, t-t0-meas.t(end), Sigma_gyr);
        [x, P] = mu_normalizeQ(x, P);
      else
        P=P*eye(4);
      end
      acc = data(1, 2:4)';

      if ~any(isnan(acc))  % Acc measurements are available.
          if norm(acc)>0.9*norm(g0) && norm(acc)<1.1*norm(g0)
            [x, P] = mu_g(x, P, acc, Sigma_acc, g0);
            [x, P] = mu_normalizeQ(x, P);
            ownView.setAccDist(false);
          else
            ownView.setAccDist(true);
          end
      end
      mag = data(1, 8:10)';
      if ~any(isnan(mag))  % Mag measurements are available.
          L=0.98*L+0.02*norm(mag);
          % disp(L)
          if L>20 && L<40
              [x, P] = mu_m(x, P, mag, m0, Sigma_mag);
              [x, P] = mu_normalizeQ(x, P);
              ownView.setMagDist(false);
          else
              ownView.setMagDist(true);
          end
        % Do something
      end

      orientation = data(1, 18:21)';  % Google's orientation estimate.

      % Visualize result
      if rem(counter, 10) == 0
        setOrientation(ownView, x(1:4));
        title(ownView, 'OWN', 'FontSize', 16);
        if ~any(isnan(orientation))
          if isempty(googleView)
            subplot(1, 2, 2);
            % Used for visualization.
            googleView = OrientationView('Google filter', gca);
          end
          setOrientation(googleView, orientation);
          title(googleView, 'GOOGLE', 'FontSize', 16);
        end
      end
      counter = counter + 1;

      % Save estimates
      xhat.x(:, end+1) = x;
      xhat.P(:, :, end+1) = P;
      xhat.t(end+1) = t - t0;

      meas.t(end+1) = t - t0;
      meas.acc(:, end+1) = acc;
      meas.gyr(:, end+1) = gyr;
      meas.mag(:, end+1) = mag;
      meas.orient(:, end+1) = orientation;
    end
  catch e
    fprintf(['Unsuccessful connecting to client!\n' ...
      'Make sure to start streaming from the phone *after*'...
             'running this function!']);
  end
end

function plothistogram(data,mu,sigma,signal)
figure('Position',[300 300 600 400]);hold on;
list={'x','y','z'};
for i=1:3
    subplot(3,1,i);hold on
    histogram(data(i,:),'Normalization','pdf','FaceColor',[.9 .9 .9]);
    % [x_plote,Ye1]=normPlot(mu(i,:),sigma(i,i));
    % plot(x_plote,Ye1,'LineWidth',2);hold off
    title('histogram of axis',list(i))
    legend('histogram')
end
figure('Position',[300 300 600 400]);hold on;
for j=1:3
    subplot(3,1,j);
    plot(signal(j,:),'LineWidth',1);
    legend('signal')
    title('signal of axis',list{j})
end
end


function [x,P] =tu_qw(x, P, omega, T, Rw)
%here is x=Fx+GVk
G=T/2*Sq(x);
F=eye(size(x,1))+T/2*Somega(omega);
x=F*x;
P=F*P*F'+G*Rw*G';
end


function [x, P] = mu_m(x, P, mag, m0,Rm)
    hx=Qq(x)'*m0;
    [Q0, Q1, Q2, Q3]=dQqdq(x);
    Hx=[Q0'*m0 Q1'*m0 Q2'*m0 Q3'*m0];
    S=Hx*P*Hx'+Rm;
    KK=P*Hx'*inv(S);
    x=x+KK*(mag-hx);
    P=P-KK*S*KK';
end


function[x, P] = mu_g(x, P, yacc, Ra, g0)
    hx=Qq(x)'*g0;
    [Q0, Q1, Q2, Q3]=dQqdq(x);
    Hx=[Q0'*g0 Q1'*g0 Q2'*g0 Q3'*g0];
    S=Hx*P*Hx'+Ra;
    KK=P*Hx'*inv(S);
    x=x+KK*(yacc-hx);
    P=P-KK*S*KK';
end
